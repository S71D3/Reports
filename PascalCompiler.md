#Pascal compiler

## IO + Лексический анализатор
Лексический анализатор – итератор по словам текста программы, параллельно переводящий слова в токены. Токен – более короткое (кодовое) представление слова программы.  
Лексический анализатор построен в виде класса. К объекту лексического анализатора можно прикрепить текст программы и затем запустить последовательный обход токенов, с помощью метода `Lexer::GetLex()`. Это основной метод, который выполняет всю основную работу по разбору (парсингу) текста, определению типа лексемы и формированию токена.  
Получение символов из текста осуществляется с помощью потокового посимвольного считывания, что соответствует концепции однопроходного комплиятора (каждый символ считывается только один раз).  
Для последующей работы синт. анализатора, класс имеет стек временных токенов `std::deque<Lexem>	tempLex;`, который позволяет временно хранить токены, для отката на любое кол-во токенов назад, без их повторного считывания (на практике - пригодился откат максимум на 3-4 токена).  
  
Класс лексем, в свою очередь, кроме хранения самой информации о считанной лексеме (*сами считанные символы, соотв. токен, номер строки*), хранит также все обрабатываемые нами токены в виде перечисления `enum tokens {...}`, а также их соответствие считанным комбинациям символов в виде словаря `static std::map<std::string, tokens> KeyWordsMap`, благодаря чему, по считанной комбинации символов, мы можем найти соотв. ей токен.  
По аналогичной схеме представлена работа с ошибками (`enum errors {...}` и `static std::map<std::string, errors> ErrorsWordsMap` соответственно).  
  
Для улучшения читаемости кода разбора текста, были использован автомат, которые разбирает слово и в зависимости от встреченных символов переходит из состояние в состояние.
![compiler automat](https://github.com/S71D3/Reports/raw/master/res/compiler1.png)

####Тестирование
код для тестирования:
```
program test1;
type
	tp = record
		x,y:integer;
	end;
	
var
	d: array [1..5] of integer;
	f: real;
	a, b, c: integer;
	e: tp;
begin
	c:=2;
	f:=3.4;
	e.y:=0;
	d[3]:=0;
	
	while d[4]>0 do begin
		c:=c+1+2*3;
	end;
	
	if e.y>0 then begin
		d[3] := c + 2.1;
	end
	else begin
		c := c + 3;
	end;
	
	with e do begin
		y:=1;
	end;
end.
```
На выходе должны получить перечисление всех токенов с их описанием, что и получаем:
```
program | program | 0
test1 | name | 0
; | ; | 0
type | type | 1
tp | name | 2
= | = | 2
record | record | 2
x | name | 3
, | , | 3
y | name | 3
: | : | 3
integer | name | 3
; | ; | 3
end | end | 4
; | ; | 4
var | var | 6
d | name | 7
: | : | 7
array | array | 7
[ | [ | 7
1 | digit | 7
.. | .. | 7
5 | digit | 7
] | ] | 7
of | of | 7
integer | name | 7
; | ; | 7
f | name | 8
: | : | 8
real | name | 8
; | ; | 8
a | name | 9
, | , | 9
b | name | 9
, | , | 9
c | name | 9
: | : | 9
integer | name | 9
; | ; | 9
e | name | 10
: | : | 10
tp | name | 10
; | ; | 10
begin | begin | 11
c | name | 12
:= | := | 12
2 | digit | 12
; | ; | 12
f | name | 13
:= | := | 13
3 | digit | 13
. | . | 13
4 | digit | 13
; | ; | 13
e | name | 14
. | . | 14
y | name | 14
:= | := | 14
0 | digit | 14
; | ; | 14
d | name | 15
[ | [ | 15
3 | digit | 15
] | ] | 15
:= | := | 15
0 | digit | 15
; | ; | 15
while | while | 17
d | name | 17
[ | [ | 17
4 | digit | 17
] | ] | 17
> | > | 17
0 | digit | 17
do | do | 17
begin | begin | 17
c | name | 18
:= | := | 18
c | name | 18
+ | + | 18
1 | digit | 18
+ | + | 18
2 | digit | 18
* | * | 18
3 | digit | 18
; | ; | 18
end | end | 19
; | ; | 19
if | if | 21
e | name | 21
. | . | 21
y | name | 21
> | > | 21
0 | digit | 21
then | then | 21
begin | begin | 21
d | name | 22
[ | [ | 22
3 | digit | 22
] | ] | 22
:= | := | 22
c | name | 22
+ | + | 22
2 | digit | 22
. | . | 22
1 | digit | 22
; | ; | 22
end | end | 23
else | else | 24
begin | begin | 24
c | name | 25
:= | := | 25
c | name | 25
+ | + | 25
3 | digit | 25
; | ; | 25
end | end | 26
; | ; | 26
with | with | 28
e | name | 28
do | do | 28
begin | begin | 28
y | name | 29
:= | := | 29
1 | digit | 29
; | ; | 29
end | end | 30
; | ; | 30
end | end | 31
. | . | 31
successed!
```

## Синтаксический анализатор
Синтаксический анализатор должен пройтись по набору токенов и проверить правильность грамматик и синтаксических конструкций языка.   
  
