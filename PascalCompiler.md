# Pascal compiler

## IO + Лексический анализатор
Лексический анализатор – итератор по словам текста программы, параллельно переводящий слова в токены. Токен – более короткое (кодовое) представление слова программы.  
Лексический анализатор построен в виде класса. К объекту лексического анализатора можно прикрепить текст программы и затем запустить последовательный обход токенов, с помощью метода `Lexer::GetLex()`. Это основной метод, который выполняет всю основную работу по разбору (парсингу) текста, определению типа лексемы и формированию токена.  
Получение символов из текста осуществляется с помощью потокового посимвольного считывания, что соответствует концепции однопроходного комплиятора (каждый символ считывается только один раз).  
Для последующей работы синт. анализатора, класс имеет стек временных токенов `std::deque<Lexem>	tempLex;`, который позволяет временно хранить токены, для отката на любое кол-во токенов назад, без их повторного считывания (на практике - пригодился откат максимум на 3-4 токена).  
  
Класс лексем, в свою очередь, кроме хранения самой информации о считанной лексеме (*сами считанные символы, соотв. токен, номер строки*), хранит также все обрабатываемые нами токены в виде перечисления `enum tokens {...}`, а также их соответствие считанным комбинациям символов в виде словаря `static std::map<std::string, tokens> KeyWordsMap`, благодаря чему, по считанной комбинации символов, мы можем найти соотв. ей токен.  
По аналогичной схеме представлена работа с ошибками (`enum errors {...}` и `static std::map<std::string, errors> ErrorsWordsMap` соответственно).  
  
Для улучшения читаемости кода разбора текста, были использован автомат, которые разбирает слово и в зависимости от встреченных символов переходит из состояние в состояние.  
![compiler automat](https://github.com/S71D3/Reports/raw/master/res/compiler1.png)

#### Тестирование  
код для тестирования:  
```
program test1;
type
	tp = record
		x,y:integer;
	end;
	
var
	d: array [1..5] of integer;
	f: real;
	a, b, c: integer;
	e: tp;
begin
	c:=2;
	f:=3.4;
	e.y:=0;
	d[3]:=0;
	
	while d[4]>0 do begin
		c:=c+1+2*3;
	end;
	
	if e.y>0 then begin
		d[3] := c + 2.1;
	end
	else begin
		c := c + 3;
	end;
	
	with e do begin
		y:=1;
	end;
end.
```  
На выходе должны получить перечисление всех токенов с их описанием, что и получаем:  
```
program | program | 0
test1 | name | 0
; | ; | 0
type | type | 1
tp | name | 2
= | = | 2
record | record | 2
x | name | 3
, | , | 3
y | name | 3
: | : | 3
integer | name | 3
; | ; | 3
end | end | 4
; | ; | 4
var | var | 6
d | name | 7
: | : | 7
array | array | 7
[ | [ | 7
1 | digit | 7
.. | .. | 7
5 | digit | 7
] | ] | 7
of | of | 7
integer | name | 7
; | ; | 7
f | name | 8
: | : | 8
real | name | 8
; | ; | 8
a | name | 9
, | , | 9
b | name | 9
, | , | 9
c | name | 9
: | : | 9
integer | name | 9
; | ; | 9
e | name | 10
: | : | 10
tp | name | 10
; | ; | 10
begin | begin | 11
c | name | 12
:= | := | 12
2 | digit | 12
; | ; | 12
f | name | 13
:= | := | 13
3 | digit | 13
. | . | 13
4 | digit | 13
; | ; | 13
e | name | 14
. | . | 14
y | name | 14
:= | := | 14
0 | digit | 14
; | ; | 14
d | name | 15
[ | [ | 15
3 | digit | 15
] | ] | 15
:= | := | 15
0 | digit | 15
; | ; | 15
while | while | 17
d | name | 17
[ | [ | 17
4 | digit | 17
] | ] | 17
> | > | 17
0 | digit | 17
do | do | 17
begin | begin | 17
c | name | 18
:= | := | 18
c | name | 18
+ | + | 18
1 | digit | 18
+ | + | 18
2 | digit | 18
* | * | 18
3 | digit | 18
; | ; | 18
end | end | 19
; | ; | 19
if | if | 21
e | name | 21
. | . | 21
y | name | 21
> | > | 21
0 | digit | 21
then | then | 21
begin | begin | 21
d | name | 22
[ | [ | 22
3 | digit | 22
] | ] | 22
:= | := | 22
c | name | 22
+ | + | 22
2 | digit | 22
. | . | 22
1 | digit | 22
; | ; | 22
end | end | 23
else | else | 24
begin | begin | 24
c | name | 25
:= | := | 25
c | name | 25
+ | + | 25
3 | digit | 25
; | ; | 25
end | end | 26
; | ; | 26
with | with | 28
e | name | 28
do | do | 28
begin | begin | 28
y | name | 29
:= | := | 29
1 | digit | 29
; | ; | 29
end | end | 30
; | ; | 30
end | end | 31
. | . | 31
successed!
```

## Синтаксический анализатор
Синтаксический анализатор должен пройтись по набору токенов и проверить правильность грамматик и синтаксических конструкций языка.   
Также именно на этом этапе происходит определение типа константы (integer или real, в нашем случае)  
#### Проектирование
В начале нужно было определиться с грамматиками. Они представлены в виде БНФ, для каждой было принято решение реализовать функцию вида: `Syntax::Compile<Имя грамматики>(...)`. И того получилось 40 функции, распознающих, соответственно, 40 различных грамматик.  
![grammatic diagram](https://github.com/S71D3/Reports/raw/master/res/compiler2.png)  
## Семантический анализатор
Семантический анализатор должен хранить информацию о всех объявленных идентификаторах (переменных, типах, константах), а также проверять исполнение неформальных соглашений языка Паскаль (соответствие типов данных в выражении).  
Реализация семантического анализатора осуществлялась путем модификации БНФ-функций, реализованных на этапе синтаксического анализатора, а также добавлением стека переменных и типов.
#### Проектирование
Для хранения стека переменных и типов было решено использовать вектора (`std::vector<Variable> variables` и `std::vector<Type*> types`), где:
 * класс `Variable` содержит поля `std::string name` и `Type* type`
 * класс `Type` содержит поля:
	* `std::string name` - содержащее имя типа
	* `std::string typeDef` - содержащее название типа у типа:)
	* `bool isScalar` - содержащее информацию о скалярности типа  
	
при этом класс `Type` имеет дочерние классы, каждый из которых используется для хранения описанных в требовании типов и их особенностей:
	
 * `class DefaultType : public Type`
	 * используется для хранения дефолтных типов, используемых паскалем (integer, real, char...)
 * `class SimpleType : public Type`
	 * используется для пользовательских простых типов и имеет дополнительное поле `Type parentType`, хранящее родительский тип
 * `class BoundedType : public Type`
	 * используется для т.н. "ограниченных типов" вида [X..Y], и имеет поля `std::string boundTop` и `std::string boundDown`, для хранения соотв. верхней и нижней границ
 * `class ArrayType : public Type`
	 * используется для array-типов, и имеет поля `std::vector<Type*> inTypes`, для хранения вложенных типов (в квадратных скобках после ключ. слова `array`) и `Type parentType`, для хранения родительского типа
 * `class RecordType : public Type`
	 * используется для record-типов, и имеет поле `std::vector<Field> fields`, используемое для хранения списка полей, которые, по сути, являются переменными  

Для большего понимания, диаграмма всех описанных выше классов:
![types and variables diagram](https://github.com/S71D3/Reports/raw/master/res/compiler3.png)
